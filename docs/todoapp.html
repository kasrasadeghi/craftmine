<html>
<head>
  <style>

    .category {
      /* border: 1px solid black; */
      margin-bottom: 10;
    }
    .category>h3 {
      margin-left: 0.5%;
      margin-block-start: 0;
      margin-block-end: 0;
    }
    .store {
      /* TODO */
    }
    .todo {
      list-style: none;
      margin-left: 2%;
      padding-top: 0.5%;
      padding-bottom: 0.5%;
      border-bottom: 1px solid black;
    }
    .todo:first-of-type {
      border-top: 1px solid black;
    }
    .brand {
      color: #444
    }
    .content {
      margin-left: 2%;
      width: 90%;
    }
    .navbar {
      display: flex;
    }
    .navbuttons {
      margin-block-start: 0;
      margin-block-end: 0;
    }
    html {
      padding-bottom: 90%;
    }
  </style>
  <script>

  state = {
    misc:
    `negative world chunks
    chunk load and unload from disk
    only instance gen for chunks that have neighbors
    make text renderer draw on near plane
    fix blocks placed on chunk boundary issues`,
    features:
    `investigate shadow volumes
    make terrain generation seed-based
    anti aliasing
    texture interpolation instead of color interpolation
    inventory
    day night cycle
    draw player
    player shadow
    rivers`,
    improvements_and_user_ex:
    `investigate making glad a static lib
    make better fog
    handle resizes
    runescape less strong
    extreme hill only sometimes
    neighboring chunks on break refresh a lot`,
    optimization:
    `-> async
    16^3 chunks instead of 16^2 x 128 chunks?
    make transparency cache for chunk instance building?
    make orthographic matrix depend on render distance
    make shadow texture size depend on render distance
    mipmap shadows
    downsample with intelligent interpolation
    make caves not iterate through every previous cave to run`,
    async:
    `instance gen
    terrain gen
    separate terrain gen into individual passes`,
    bugs:
    `need to put a mutex around {the body of the worker thread} and {the instance building}. chunk's backing store might be resized`,
  };

  let selected_node = null;

  function patch(node, attrs) {
    for (let field in attrs) {
      node.setAttribute(field, attrs[field]);
    }
  };

  function store() {
    const todos_node = document.getElementById('todos');
    // iterate through the todos and make a json
    let data = [];
    for (const child of todos_node.children) {
      const category = child.firstElementChild.innerText;

      let todos = [];
      for (let todo of [...child.children].slice(1) /* ignore the category title */) {
        todos.push(todo.innerText);
      }
      data.push({category, todos})
    }

    window.external.invoke(JSON.stringify(data, null, 2));
  }

  function load() {
    let node = document.getElementById('todos');
    let cNode = node.cloneNode(false);
    node.parentNode.replaceChild(cNode, node);
    window.external.invoke('load');

    render(state);
  }

  function dragstart(ev) {
    let node = ev.target;
    selected_node = node;
    patch(selected_node, {style: 'color: grey'});
    ev.dataTransfer.setData('text', ev.target.innerText);
  };

  function allowDrop(ev) {
    ev.preventDefault();
  };

  function drop(ev, category_name) {
    ev.preventDefault();
    ev.target.after(selected_node);
    patch(selected_node, {style: 'color: black'});
    selected_node = null;
  };

  function render(data) {
    let elem = (tagname, content = '', attrs, children) => {
      let node = document.createElement(tagname);
      node.append(content);
      patch(node, attrs);
      if (children) {
        for (let child of children) {
          node.appendChild(child);
        }
      }
      return node;
    };

    body = document.getElementById('todos');
    for (let name in data) {
      let node = 
        elem('ul', '', { class: 'category collection', 
                         ondrop:`drop(event, "${name}")`, 
                         ondragover:'allowDrop(event)' }, 
          [elem('h3', name + ':', {}, [])]);

      for (let todo_text of data[name].split('\n').map((l) => l.trim())) {
        let todo = elem('li', todo_text, {class: 'todo collection-item', draggable: 'true', ondragstart: 'dragstart(event)'}); 
        node.appendChild(todo);
      }

      body.appendChild(node);
    }
  }

  window.onload = () => {
    render(state);
  };
  </script>
</head>
<body>
  <div class='content'>
    <nav class='navbar'>
      <a href='#' class='brand'>Todo</a>
      <ul class='navbuttons' class=''>
        <li><a href='#' class='store' onclick='store(event)'>store</a></li>
        <li><a href='#' class='load' onclick='load(event)'>load</a></li>
      </ul>
    </nav>
    <div id='todos'></div>
  </div>
</body>
</html>